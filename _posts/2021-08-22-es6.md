---
git@gitee.com:sjdt/geekhall.cn.gitlayout: post
title:  "ES6 笔记"
date:   2021-08-22 12:10:25 +0800
categories: ES6
---

# ES6笔记

## ES6特性
### let与var的区别：
* 使用let声明变量，不能重复声明
* 块儿级作用域
* 不存在变量提升
* 不影响作用域链

### 使用const声明常量时一定要赋初始值

### 解构赋值
ES6允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。
1. 数组的解构
   ```javascript
   const F4=['小沈阳','刘能','赵四','宋小宝']
   let [a,b,c,d] = F4;
   console.log(a);
   ```
2. 对象的解构
   ```javascript
   const zhao = {
        name: '赵本山',
        age: 60,
        xiaopin: function(){
            console.log("赵本山会演小品.");
        }
    }
    //zhao.xiaopin();
    let {xiaopin} = zhao;
    xiaopin();
    ```

3. ES6 引入了新的声明字符串的方式：``
反引号内容中可以直接出现换行符

梵音好重可以使用${}来进行变量拼接
```javascript
let act="葛优";
let msg=`${act}是一个好演员`;
```

4. ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。
   ```javascript
    let name = "极客堂";
    let change = function (){
        console.log("我们可以改变你！");
    }

   const school = {
       // 
       // name: name,
       // change: change,
       // 属性名和变量名相同时，可以省略成下面的形式
        name,
        change, 
        origin: function(){
            console.log("原来的方法定义方式。")
        },
        improve(){
            console.log("ES6支持的方法定义方式。")
        }
    }

    console.log(school);
    school.origin();
    school.improve();
   ```
5. ES6允许使用箭头 （=>） 定义函数。
```javascript
let fn = function(){
    console.log("function1");
}

let fn1 = (a,b) => {
    console.log("function2");
    return a + b;
}

fn();
fn1(1,2);
```

需要注意的：
* this是静态的，this始终指向函数声明时所在作用域下的this的值。
```javascript
function getName(){
        console.log(this.fname);
    }
    let getName2 = () => {
        console.log(this.fname);
    }

    window.fname = "name in window";
    const geekA = {
        fname: "name in geekA"
    }

    // 直接调用，都返回"name in window"
    getName(geekA);
    getName2(geekA);

    // call 方法调用则不同
    // 由于getName2方法声明时，this指向window，
    // 所以函数内也一直指向window
    getName.call(geekA);    //  name in geekA
    getName2.call(geekA);   //  name in window
```

* 不能作为构造实例化对象
```javascript
// 不能作为构造实例化对象，
// 比如下面的代码会报错：Uncaught TypeError： Person is not a constructor.
let Person = (name, age) => {
    this.name = name;
    this.age = age;
}
let me = new Person('xiao', 30);
console.log(me);
```

* 不能使用arguments变量
```javascript
// 比如下面的代码会报错：Uncaught ReferenceError： argumenets is not defined.
let fn = () => {
    console.log(arguments);
}
fn(1,2,3);
```
* 箭头函数的简写
```javascript
// 箭头函数的简写
// 当形参有且只有一个的时候可以省略小括号：
let fn_add = n => {
    return n+n;
}
console.log(fn_add(3));

// 当代码体只有一条语句的时候，可以省略花括号：
// 省略花括号时return也必须省略。
let fn_pow = n => n*n;
console.log(fn_pow(4));
```
* 箭头函数的实践
```html
    <title>箭头函数实践</title>
    <style>
        div{
           width: 200px;
           height: 200px;
           background: #58a; 
           margin:2rem;
        }
    </style>
</head>
<body>
    <div id="ad"></div>

    <div id="ad2"></div>
    <script>
        // 需求-1 点击div 2s 后颜色变成粉色
        let ad = document.getElementById('ad');
        ad.addEventListener("click", function(){ 
            // 注意这里不能在定时器种直接使用this，
            // 因为定时器中的this指向window。
            // 所以这里需要使用self临时保存this。
            let self = this;
            setTimeout(function(){
                console.log(self);
                console.log(this);
                // 这里使用this会报错，因为当前内层函数的this指向了window
                // this.style.background = 'pink';

                // 这里在内层函数中找不到self，就会继续向外层函数查找self
                self.style.background = 'pink';

            }, 2000);
        })

        // 而有了箭头函数之后，上面的问题就可以得到解决了
        let ad2 = document.getElementById('ad2');
        ad2.addEventListener("click", function(){ 
            setTimeout(() => {
                console.log(self);
                console.log(this);
                this.style.background = 'pink';
            }, 2000);
        })
    </script>
</body>
```

箭头函数可以使函数更加简洁，例如下面的取数组偶数项的函数：
```javascript
const arr = [1,2,3,4,5,6];
const result = arr.filter(function(item){
    if(item % 2 === 0 ){
        return true;
    } else {
        return false;
    }
});
```
可以简化为：
```javascript
const result2 = arr.filter(item => item % 2 === 0);
```

需要注意的是箭头函数不适合与`this`有关的回调，事件回调，对象的方法。



### ES6 允许给函数参数赋初始值

```javascript
function add(a,b,c=10){
    return a+b+c;
}

console.log(add(1+2)); //13
```

参数默认值可以与解构赋值结合使用
```javascript
function connect({host="127.0.0.1", username, password, port}){
    console.log(host);
    console.log(username);
    console.log(password);
    console.log(port);
};
connect({
    host: 'localhost',
    username: 'root',
    password: '123456',
    port: 3306
});

```
### ES6 引入了rest参数，用于获取函数的实参，用来代替arguments
注意rest参数必须要放到参数的最后
```javascript
// ES5 的方式
// Arguments是一个对象
function normal_fn(){
    console.log(arguments);
}

normal_fn('a','b','c',100)

// ES6 的方式（REST方式）
// args是一个数组，参数处理更加灵活。
function normal_fn2(arg1, arg2, ...args){
    console.log(args);
}

normal_fn2('a','b','c',200);
```


### ... 扩展运算符能将数组转换为逗号分隔的“参数序列”
```javascript
const tfboys = ['易洋千玺','王源','王俊凯'];

function chunwan(){
    console.log(arguments);
}

chunwan(tfboys);
chunwan(...tfboys); // 等同于chunwan('易洋千玺','王源','王俊凯')
```
![](https://yinyang.space/img/20210821_es6_1.png)


可以用来数组的合并或者克隆

```javascript
const kuaizi = ['王太利', '肖央'];
const fenghuang = ['曾毅', '玲花'];
const zuixuanxiaopingguo = kuaizi.concat(fenghuang);
const zxxpg = [...kuaizi, ...fenghuang]
console.log(zuixuanxiaopingguo);
console.log(zxxpg);

const arr1 = ['a','b','c'];
const arr2 = [...arr1];

```



### ES6引入了Symbol
ES6引入了一种新的原始数据类型Symbol，表示一种独一无二的值，它是JavaScript语言的第七种数据类型。
是一种类似于字符串的数据类型。
Symbol的特点：
* Symbol的值是唯一的，用来解决命名冲突的问题
* Symbol值不能与其他数据类型进行运算
* Symbol定义的对象属性不能使用`for...in`循环遍历，但是可以使用`Reflect.ownKeys`来获取对象的所有键名。

```javascript
let s = Symbol();
console.log(s, typeof s);

let s2 = Symbol("GeekHall");
let s3 = Symbol("GeekHall");

console.log(s2 === s3); // false 


let s4 = Symbol.for('GeekHall');
let s5 = Symbol.for('GeekHall');
console.log(s4, typeof s4);

console.log(s4 === s5); // true
```

### JavaScript数据类型
```
USONB you are so niubility!
u : undefined
s : string symbol
o : object 
n : null number
b : boolean


```


可以使用Symbol安全地向对象追加方法：
下面的game中已经有一个up方法了，使用Symbol可以保证原对象中的方法不会被覆盖。
```javascript

let game = {
    name: '俄罗斯方块',
    level:10,
    up: function() {
        console.log("up method");
    }
}

let methods = {
    up: Symbol(),
    down: Symbol()
};

game[methods.up] = function() {
    console.log("改变形状");
}

game[methods.down] = function() {
    console.log("快速下降");
}

console.log(game);
```

![](https://yinyang.space/img/20210821_es6_2.png)


### 给对象添加Symbol类型的属性：
```javascript
let say = Symbol('say');
let zibao = Symbol('zibao');
let youxi = {
    name: "狼人杀",
    [say]: function() {
        console.log("我可以发言");
    },
    [zibao]: function() {
        console.log("我可以自爆");
    }
};

console.log(youxi);
youxi[say]();       // 打印 我可以发言
youxi[zibao]();     // 打印 我可以自爆
```






### Symbol内置值
ES6提供了11个内置的Symbol值
|值|用途|
|---|---|
|Symbol.hasInstance|当其他对象使用instanceof运算符，判断是否为该对象的实例时会调用这个方法|
|Symbol.isConcatSpreadable |对象的Symbol.isConcatSpreadable属性等于的是一个bool值，表示该对象用于Array.prototype.concat()时，是否可以展开 |
|Symbol.unscopables |该对象使用with关键字时，哪些属性会被with环境排除 |
|Symbol.match |当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值 |
|Symbol.replace |当该对象被str.replace(myObject)方法调用时，会返回该方法的返回值。 |
|Symbol.search |当该对象被str.search(myObject)方法调用时，会返回该方法的返回值。 |
|Symbol.split |当该对象被str.split(myObject)方法调用时，会返回该方法的返回值。 |
|Symbol.iterator |对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认迭代器 |
|Symbol.toPrimitive |该对象被转为原始类型值时，会调用这个方法，返回该对象对应的原始类型值 |
|Symbol.toStringTag |在该对象上面调用toString方法时，返回该方法的返回值 |
|Symbol.species |创建衍生对象时，会使用该属性 |





```javascript
class Person{
    static [Symbol.hasInstance](param){
        console.log("我被用来检测类型了！");
    }
}

let o = {};
console.log(o instanceof Person); 
// 打印：
// 我被用来检测类型了！
// false
```

```javascript
const arr = [1,2,3]
const arr2 = [4,5,6]
arr2[Symbol.isConcatSpreadable] = false;
console.log(arr.concat(arr2));

```
![](https://yinyang.space/img/20210821_es6_3.png)






### 迭代器
迭代器（iterator）是一种接口，为各种不同数据结构提供统一的访问机制。
任何数据结构之遥部署了iterator接口就可以完成遍历操作。
* ES6创造了一种新的遍历命令：for...of循环，iterator接口主要供for...of消费。
* 原生具备iterator接口的数据包括：
  - Array
  - Arguments
  - Set
  - Map
  - String
  - TypedArray
  - NodeList

```javascript
const books = ['西游', '红楼','水浒', '三国'];

for (let book of books){
    console.log(book);
}
```

使用iterator可以自定义对象的遍历方法
```javascript
const actors = {
    name: "四大才子",
    code:[
        "刘能",
        "小沈阳",
        "宋小宝",
        "赵四"
    ],
    [Symbol.iterator](){
        let index = 0;
        let self = this;
        return {
            next: function(){
                if (index < self.code.length){
                    const result = {
                        value: self.code[index], 
                        done: false
                    };
                    index++;
                    return result;
                } else {
                    return {value:undefined, done: true};
                }
            }
        };
    }
}

for (let actor of actors){
    console.log(actor);
}

```

### 生成器
生成器其实就是一个特殊的函数，是一种异步编程的解决方案，
在声明函数的时候在函数名前加一个星号 * ，使用的时候借助iterator的next()方法来调用。

```javascript
function * gen(){
    console.log("111");
    yield '一只没有耳朵';

    console.log("222");
    yield '一只没有尾巴';

    console.log("333");
    yield '真奇怪';

    console.log("444");

    let iter = gen();
    iter.next();
    console.log("============华丽的分割线1============");
    iter.next();
    console.log("============华丽的分割线2============");
    iter.next();
    console.log("============华丽的分割线3============");
    iter.next();
}

```
![](https://yinyang.space/img/20210821_es6_4.png)


```javascript
for (let v of gen()){
    console.log("============华丽的分割线============");
    console.log(v);
}
```
打印结果：

![](https://yinyang.space/img/20210821_es6_5.png)

可以看到每次调用`next`的返回值为`yield`后定义的值。

