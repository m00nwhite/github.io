---
layout: post
title:  "Vue 笔记"
date:   2021-08-27 12:10:25 +0800
categories: vue
---
* 目录
{:toc}

# Vue 笔记
## 背景知识
Vue(读音/vju:/)是一套用于构建用户界面的渐进式框架，发布于2014年2月。Vue被设计为可以自底向上组层应用。

Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。

### Vue的一些常用第三方库
* vue-router：路由
* vue-resource： 通信
* vuex： 管理

### 前端的一些常用工具
* CSS预处理
  - SASS：基于Ruby，通过服务端处理，功能强大，解析效率高，需要学习Ruby语言，上手难度稍高。
  - LESS：基于NodeJS，通过客户端处理，使用简单，功能比SASS简单，解析效率也稍低。

* JavaScript框架
  - jQuery： 优点是简化DOM操作，缺点是DOM操作太频繁，影响前端性能，在前端眼里使用它仅仅是为了兼容IE6-8
  - Angular： Google收购的前端框架，由一群Java程序员开发，特点是将后台MVC的开发模式搬到了前端并增加了**模块化开发**的理念，采用TypeScript语法，对前端开发人员不太友好。
  - React： FaceBook出品，一款高性能的JS前端框架，特点是提出了新概念【虚拟DOM】，在内存中模拟DOM并进行Diff算法，用于减少DOM操作，有效提高了渲染效率；缺点是使用复杂，需要额外学习一门【JSX】语言
  - Vue： 一款渐进式JavaScript框架，综合了Angular和React的优点。
  - Axios：前端通信框架，用来处理异步通信。

* UI框架
  - Ant-Design：阿里巴巴出品，基于React的UI框架
  - Element-UI：饿了么出品，基于Vue的UI组件库，组件齐全，基本涵盖了后端所需要的所有组件，文档详细案例丰富，主要用于PC端，是一个质量较高的组件库。前端主流框架，选型时可以考虑，主要特点是PC端支持较多。
  - iview：饿了么出品，基于Vue的UI框架，有很多实用的基础组件，比ElementUI更丰富，主要服务于PC界面的中后台产品，使用单文件的Vue组件化开发模式，
    基于npm+webpack+babel开发，属于前端主流框架，选型时可以考虑使用，主要特点是移动端支持较多。
  - ice：饿了么出品，基于Vue的UI框架，是阿里巴巴团队基于Angular/React/Vue的中后台解决方案，在阿里巴巴内部已经有270多个来自几乎所有BU的项目在使用，飞冰包含了一条从设计到开发的完整链路，帮助用户快速搭建自己的中后台应用。
  - Bootstrap：Twitter推出的一个用于前端开发的开源包
  - AmazeUI：妹子UI，一款HTML5跨屏前端框架。
  - LayUI：
* 构建工具
  - Babel： JS编译工具，主要用于浏览器不支持的新特性，比如用于编译TypeScript
  - WebPack：模块打包器，主要作用是打包、压缩、合并以及按序加载
  - Gulp：自动化任务执行工具
* 三端统一
  混合开发（Hybrid App）
    
    主要目的是实现一套代码三端共用（PC、Android:.apk、iOS:.ipa）并能够掉用到设备底层硬件，比如传感器、GPS、摄像头等
    打包方式主要有以下两种
  - 云打包：HBuild -> HBuildX, DCloud出品； API Cloud
  - 本地打包：Cordova（前身是PhoneGAP）



## Vue安装
Vue官网： [vuejs.org](https://vuejs.org)

可以使用以下几种方式来安装使用Vue
1. 下载vue.js后直接放在项目工程中引用
   下载地址：https://cn.vuejs.org/v2/guide/installation.html
   
   ![](https://yinyang.space/img/20210828_vue_01.png)

2. 使用CDN
开发环境
```html
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
```

生产环境
```html
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14"></script>
```

使用原生ES Modules
```javascript
<script type="module">
  import Vue from 'https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.esm.browser.js'
</script>
```

使用NPM安装（构建大型应用时推荐使用NPM安装）

```bash
cd front;
npm install vue
npm install -g vue
npm install -g vue-cli
npm install -g webpack

```


## 初识Vue

第一个Vue页面
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello Vue</title>
    <script type="text/javascript" src="../js/vue.js"></script>
</head>
<body>
    <!-- 准备好一个容器 -->
    <div id="root">
        <h1>Hello, {{name}}</h1>
    </div>
    <script>
        Vue.config.productionTip = false  // 阻止 vue在启动时生成生产提示。

        // 创建 Vue 实例
        const vm = new Vue({
            el:'#root',     // el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。
            data:{          // data用于存储数据
                name: 'Vue'
            }
        });
    </script>
</body>
</html>
```

* 想让Vue工作，需要创建一个Vue实例，并且要传入一个配置对象；
* root容器里的代码依然符合html规范；
* root容器与Vue实例之间是一一对应的，一般真实开发中只有一个Vue实例，并且会配合着组件一起使用；
* `{{ }}`中可以放置js表达式，比如`{{1+1}}`，`{{Date.now()}}`；
* 一旦data中的数据发生改变，那么页面模版中用到该数据的地方也会自动更新。


```html
<div id="root1">
    <h1>Hello, {{name}}, {{age}}</h1>
</div>
<div id="root2">
    <h1>Hello, {{name}}, {{address}}</h1>
</div>
<script>
    Vue.config.productionTip = false  // 阻止 vue在启动时生成生产提示。

    // 创建 Vue 实例
    const vm1 = new Vue({
        el:'#root1',     // el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。
        data:{          // data用于存储数据
            name: 'Vue',
            age: 18
        }
    });
    const vm2 = new Vue({
        el:'#root2',     // el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。
        data:{          // data用于存储数据
            name: 'GeekHall',
            address: 'beijing'
        }
    });
</script>
```

输出结果
```
Hello, Vue, 18
Hello, GeekHall, beijing
```


## Vue 开发者工具
上面的案例在执行的时候F12打开控制台会看到下面的一行提示内容
![](https://yinyang.space/img/20210828_vue_03.png)

是因为我们没有安装Vue开发者工具

可以在VueDevTools官网[https://devtools.vuejs.org/](https://devtools.vuejs.org/)

或者GitHub[https://github.com/vuejs/devtools](https://github.com/vuejs/devtools)

来下载安装

Chrome浏览器可以在Chrome 网上商店直接下载安装
![](https://yinyang.space/img/20210828_vue_04.png)


使用：
可以直接在F12界面中找到Vue开发者工具的Tab页，在这里可以直接执行修改绑定数据等操作。
![](https://yinyang.space/img/20210828_vue_02.png)

另外一个需要注意的是，如果使用`file://`的方式打开html的话开发者工具是不会生效的。
![](https://yinyang.space/img/20210828_vue_06.png)

这里推荐使用VSCode的liveServer扩展，可以直接在vscode中使用`http://127.0.0.1:5500`来调试本地html。


## Vue常用7个属性
学习Vue我们必须知道它的7个属性，8个方法，以及7个指令（787原则）
* el属性：用来指示vue编译器从什么地方开始解析vue的语法，可以说是一个占位符；
* data属性：用来组织从view中抽象出来的属性，可以说将视图的数据抽象出来存放到data中；
* template属性：用来设置模板，会替换页面元素，包括占位符；
* methods属性：放置页面中的业务逻辑，js方法一般都放置在methods中；
* render属性：创建真正的Virtual DOM；
* computed属性：用来计算；
* watch属性：
  - watch:function(new, old)){}
  - 监听data中数据的变化
  - 两个参数，一个返回新值，一个返回旧值


## Vue模版语法
1. 插值语法（Interpolation）

```html
    <div id="root">
        <h1>Hello, {{name}}</h1>
    </div>
    <script>
        Vue.config.productionTip = false;
        new Vue({
            el:'#root',  
            data:{         
                name: 'Vue'
            }
        });
    </script>
```


2. 指令语法（v-bind）
指令语法用于解析标签（包括：标签属性、标签体内容、绑定事件……）

v-bind会把引号中的内容当作js表达式来执行

```html
<div id="root">
    <h1>指令语法：</h1>
    <!--
        这里会把引号内的url当作js表达式来执行，
        并将执行结果https://geekhall.cn绑定给href属性。
    -->
    <a v-bind:href="url">极客堂</a>
</div>
<script>
    Vue.config.productionTip = false;
    new Vue({
        el:'#root',  
        data:{         
            name: 'Vue',
            url: 'https://geekhall.cn'
        }
    });
</script>
```

插值语法一般用在标签体内容，
指令语法一般用在标签属性内容，

3. 双向数据绑定

```html
<div id="root">
    <h1>单向数据绑定</h1>
    <input type="text" v-bind:value="name1">
    <hr/>
    <h1>双向数据绑定</h1>
    <input type="text" v-model:value="name2">
</div>
<script>
    Vue.config.productionTip = false  // 阻止 vue在启动时生成生产提示。

    // 创建 Vue 实例
    new Vue({
        el:'#root',
        data:{
            name1: 'Vue',
            name2: 'Vue'
        }
    });
</script>
```
![](https://yinyang.space/img/20210828_vue_07.png)

注意v-model只能应用在表单类元素上。

`v-bind:name`可以简写成`":name"`

例如：`v-bind:href="xxx"` 可以简写为：`:href="xxx"` ，

`v-model:value`可以简写成`"v-model"`

例如：`v-model:value="xxx"` 可以简写为：`v-model="xxx"` ，


## 另一种绑定元素的方法

除了使用el来绑定页面元素后，还可以使用mount来绑定元素。
```javascript

<div id="root">
    <div>
        <h1>Hello, {{name}}</h1>
    </div>
</div>
<script>
    Vue.config.productionTip = false  // 阻止 vue在启动时生成生产提示。

    // 创建 Vue 实例
    const v = new Vue({
        // el:'#root',
        data:{
            name: 'Vue'
        }
    });
    v.$mount('#root');
</script>
```

## data的另一种写法(函数式)

```javascript
const vm = new Vue({
    data: function(){
        console.log('@@@@@:', this);
        return{
            name: "Vue"
        }
    }
});

v.$mount('#root');
        
```
注意这里的data函数不能写成箭头函数，否则函数内的this会指向Window，而不是Vue实例了。
* 由Vue所管理的函数，一定不要使用箭头函数。

但是可以简写成下面的方式：
```javascript
const vm = new Vue({
    data(){
        console.log('@@@@@:', this);
        return{
            name: "Vue"
        }
    }
});
```

## MVVM模型
* M：Model，data中的数据
* V：View， 模版代码
* VM： 视图模型，Vue实例

Tips
* data中所有的属性，最后都出现在了vm身上
* vm的所有的属性，及Vue原型上所有的属性，在Vue模版中都可以直接使用。

### Getter和Setter

```javascript
let number = 18;
let person = {
    name: '赵四',
    sex: 'Male'
}
Object.defineProperty(person, 'age', {
    get: function (){
        return number;
    }
    set(value) {
        number = value;
    }
}

console.log(person); 
```
Setter使用的是_data

一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；

### 数据代理
通过一个对象代理对另一个对象中属性的操作
将data中的属性通过Object.defineProperty来绑定_data，从而方便的操作data中的属性。
_data中做了数据劫持（响应式的原理）


## v-on事件处理
* 使用v-on:xxx 或者@xxx来绑定事件，其中xxx为事件名；
* 事件的回调函数需要配置在methods对象中，最终会在vm上；
* methods中配置的函数，都是被Vue所管理的函数，this的指向是vm或者组件实例对象；
* methods中配置的函数，不要使用箭头函数，否则this就不是vm了；
* @click="demo" 和 @click="demo($event)" 效果一般，但后者可以传参;(实际测试即使不使用$event,在函数中也还是可以取得event的。)
* 

```html
<div id="root">
    <h2>欢迎来到{{name}}学习</h2>
    <!-- <button v-on:click="showInfo">点我弹出提示信息</button> -->
    <!-- 简写形式 -->
    <button @click="showInfo1">点我弹出提示信息1</button>
    <!-- 传递参数 -->
    <button @click="showInfo2(666)">点我弹出提示信息2</button>
    <!-- 传递参数 -->
    <button @click="showInfo3($event,666)">点我弹出提示信息3</button>
</div>

<script>
    Vue.config.productionTip = false  // 阻止 vue在启动时生成生产提示。
    let vm = new Vue({
        el: '#root',
        data: {
            name: '极客堂'
        },
        methods: {
            showInfo1(event){
                console.log(event.target.innerText);    // 点我弹出提示信息
                console.log(this === vm);               // true, 此处的this是vm
                alert("你好，欢迎你");
            },
            showInfo2(number){
                console.log(number);                    // 666
                console.log(event.target.innerText);    // 点我弹出提示信息2
                console.log(this === vm);               // true, 此处的this是vm
                // alert("你好，欢迎你!!!");
            },
            showInfo3(number){
                console.log(number);                    // 666
                console.log(event.target.innerText);    // 点我弹出提示信息3
                console.log(this === vm);               // true, 此处的this是vm
                // alert("你好，欢迎你!!!");
            }
        }
    });
</script>
```


## 修饰符
Vue中的事件修饰符：
1. prevent：阻止默认行为（常用）；
2. stop：阻止事件冒泡（常用）；
3. once：事件只触发一次（常用）；
4. capture：使用事件的捕获模式；
5. self：只有event.target是当前操作的元素时才触发事件；
6. passive：事件的默认行为立即执行，无需等待事件的回调执行完毕；

例如，下面的`@click.prevent`就等价于`e.preventDefault();`
```html
<div id="root">
    <h2>欢迎来到{{name}}</h2>
    <a href="https://geekhall.cn" @click.prevent="showInfo">点我提示信息</a>
</div>

<script>
    Vue.config.productionTip = false  // 阻止 vue在启动时生成生产提示。
    let vm = new Vue({
        el: '#root',
        data: {
            name: '极客堂'
        },
        methods: {
            showInfo(e){
                // e.preventDefault(); // 阻止默认行为
                alert("test");
            }
        }
    });
</script>


```

使用@click.stop：阻止事件冒泡；
```html
<div class="demo1" @click="showInfo" style="background-color:skyblue; padding:1rem">
    <button @click.stop="showInfo">点我提示信息</button>
</div>
```


### 键盘事件
```html
<div id="root">
    <h2>欢迎来到{{name}}</h2>
    <input type="text" placeholder="按下回车提示输入" @keyup="showInfo"/>
</div>

<script>
    Vue.config.productionTip = false  // 阻止 vue在启动时生成生产提示。
    let vm = new Vue({
        el: '#root',
        data: {
            name: '极客堂'
        },
        methods: {
            showInfo(e){
                if (e.keyCode == 13)    // 只有当按下回车时才显示内容
                    console.log(e.target.value); 
            }
        }
    });
</script>
```
`@click.prevent`和`@click.stop;`可以连着写成`@click.prevent.stop`;



Vue的写法：
```html
<div id="root">
    <h2>欢迎来到{{name}}</h2>
    <input type="text" placeholder="按下回车提示输入" @keyup.enter="showInfo"/>
</div>

<script>
    Vue.config.productionTip = false  // 阻止 vue在启动时生成生产提示。
    let vm = new Vue({
        el: '#root',
        data: {
            name: '极客堂'
        },
        methods: {
            showInfo(e){
                console.log(e.target.value); 
            }
        }
    });
</script>
```

Vue中常见的按键别名：
* 回车 enter
* 删除 delete
* 退出 esc
* 空格 space
* Tab tab
* 上 up
* 下 down
* 左 left
* 右 right


### 计算属性

```html
<div id="root">
    <h2>使用计算属性实现姓名合并</h2>
    姓：<input type="text" v-model="firstName"/><br/><br/>
    名：<input type="text" v-model="lastName"/><br/><br/>
    <!-- 全名： <span>{{fullName()}}</span> -->
    全名： <span>{{computedFullName}}</span>
</div>

<script>
    Vue.config.productionTip = false  // 阻止 vue在启动时生成生产提示。
    let vm = new Vue({
        el: '#root',
        data: {
            firstName: '赵',
            lastName: '四'
        },
        methods: {
            fullName(){
                return this.firstName + ' - ' + this.lastName;
            }
        },
        computed: {
            
            computedFullName:{
                // Getter
                // get什么时候调用：1.初次  2.计算属性所依赖的数据发生变化时
                get(){
                    return this.firstName + ' = ' + this.lastName;
                }
            }
        }
    });
</script>

```


### 监视属性
监视属性watch

```html
<div id="root">
    <h2>监视属性</h2>
    <h2>今天天气很{{info}}</h2>
    <button @click="changeWeather">切换天气</button>
</div>

<script>
    Vue.config.productionTip = false
    const vm = new Vue({
        el: '#root',
        data: {
            isHot: true
        },
        computed: {
            info(){
                return this.isHot ? "炎热" : "凉爽"
            }
        },
        methods: {
            changeWeather(){
                this.isHot = !this.isHot
            }
        },
        watch: {
            isHot: {
                immediate: true, // 初始化时让handler调用一下
                // handler函数在isHot发生改变的时候调用。
                handler(newValue, oldValue){
                    console.log('isHot被修改了', newValue, oldValue);
                }
            }
        }
    });
    /*
    // 监视属性的另一种写法：
    vm.$watch('isHot', {
        handler(){

        }
    })
    */
</script>
```


### 深度监视
可以使用`deep: true`来开启深度监视，监视对象中所有属性的变化

```html
 <div id="root">
    <h2>监视属性</h2>
    <h2>今天天气很{{info}}</h2>
    <button @click="changeWeather">切换天气</button>
    <hr/>
    <h3>a= {{numbers.a}}</h3>
    <button @click="add">点我让a++</button>
    <hr/>
    <h3>numbers2.a= {{numbers1.a}}</h3>
    <button @click="adda">点我让a++</button>
    <h3>numbers2.b= {{numbers1.b}}</h3>
    <button @click="addb">点我让b++</button>
</div>

<script>
    Vue.config.productionTip = false
    const vm = new Vue({
        el: '#root',
        data: {
            isHot: true,
            numbers:{
                a:1,
                b:2
            },
            numbers1:{
                a:1,
                b:2
            }
        },
        computed: {
            info(){
                return this.isHot ? "炎热" : "凉爽"
            }
        },
        methods: {
            changeWeather(){
                this.isHot = !this.isHot
            },
            add(){
                this.numbers.a++;
            },
            adda(){
                this.numbers1.a++;
            },
            addb(){
                this.numbers1.b++;
            }
        },
        watch: {
            isHot: {
                immediate: true, // 初始化时让handler调用一下
                // handler函数在isHot发生改变的时候调用。
                handler(newVal, oldVal){
                    console.log('isHot被修改了', newVal, oldVal);
                }
            },
            // 监视多级结构中某个属性的变化
            'numbers.a':{
                handler(){
                    console.log('a被改变了');
                }
            },
            'numbers1':{
                deep: true, // 深度监视，监视对象中所有属性的变化，当numbers2.a 或者numbers2.b发生改变时可以检测到。默认为false。
                handler(){
                    console.log('numbers2被改变了')
                }
            }
        }
    });
</script>
```

监视的简写模式：
```javascript
watch: {
    isHot: {
        handler(newVal, oldVal){
            console.log('isHot被修改了', newVal, oldVal);
        }
    }
}
```

可以简写为下面的形式：
```javascript
watch: {
    isHot(newVal, oldVal){
        console.log('isHot被修改了', newVal, oldVal);
    }
}
```

### watch与computed的对比
* computed能够完成的功能，watch都能完成，
* watch能完成的功能，computed不一定能完成，比如：watch可以加定时器开启异步任务，computed不能

两个重要的小原则：
1. 所有被Vue管理的函数，最好写成普通函数，不要写成箭头函数，这样this的指向才是vm或者组件实例对象；
2. 所有不被Vue管理的函数，（定时器的回调函数，ajax的回调函数等，Promise的回调函数），最好写成箭头函数，这样this的指向才是vm或者组件实例对象；

```javascript
watch:{
    firstName(val){
        setTimeout(function(){
            this.fullName = val + '-' + this.lastName;
        }, 1000);
    }
}
```
### 绑定class样式
使用`:class`来绑定IGclass样式

```html
<div id="root">
    <h2>绑定样式</h2>
    <!-- 绑定变量的写法 ，适用于：样式的类名不确定，需要动态指定-->
    <div class="basic" :class="bgcolor" @click="changeColor">{{name}}</div>
    <hr>
    <!-- 绑定样式数组写法，适用于要绑定的样式名字和个数都不确定的情况 -->
    <div class="basic" :class="styles" @click="changeStyle">{{name}}</div>
    <hr>
    <!-- 绑定样式对象写法，适用于要绑定的样式个数确定，名字也确定的情况，但需要动态决定是否使用 -->
    <div class="basic" :class="classObj">{{name}}</div>
    <hr>
    <div class="basic" :style="styleObj">{{name}}</div>
</div>

<script>
    Vue.config.productionTip = false
    const vm = new Vue({
        el: '#root',
        data: {
            name: "极客堂",
            bgcolor: 'yellow',
            styles: ['center', 'big', 'bold'],
            classObj: {
                big: true,
                bold: false,
                center: true,
            },
            styleObj: {
                // 注意这里使用驼峰法命名，对应css中的font-size属性
                fontSize: '80px',
                color: 'red',
                // 注意这里使用驼峰法命名，对应css中的background-color属性
                backgroundColor: 'blue'
            }
        },
        methods: {
            changeColor(){
                const arr = ['yellow', 'green', 'cyan']
                let i = Math.floor(Math.random()*3);
                this.mood = arr[i];
            },
            changeStyle(){
                console.log("change style");
            }
        }
    });
</script>
```


## v-if

```html
<div id="root">
    <h2>v-if</h2>
    <p v-if="type==='A'">A</p>
    <p v-else-if="type==='B'">B</p>
    <p v-else-if="type==='C'">C</p>
    <p v-else="type==='D'">D</p>
</div>

<script>
    Vue.config.productionTip = false
    const vm = new Vue({
        el: '#root',
        data: {
            type: "B"
        }
    });
</script>
```

## v-for 

```html
<div id="root">
    <h2>v-for</h2>
    <ul>
        <li v-for="(book, index) in books">{{index}} : {{book.name}} - {{book.author}}</li>
    </ul>
</div>

<script>
    Vue.config.productionTip = false
    const vm = new Vue({
        el: '#root',
        data: {
            books: [
                {
                    name: '三国演义',
                    author: '罗贯中'
                },
                {
                    name: '红楼梦',
                    author: '曹雪芹'
                },
                {
                    name: '水浒传',
                    author: '施耐庵'
                },
                {
                    name: '西游记',
                    author: '吴承恩'
                }]
        }
    });
</script>
```


## template自定义组件


```html
<div id="root">
    <h2>template</h2>

    <!-- 组件： 传递给组件的值：props -->
    <geekhall v-for="item in items" v-bind:geek="item">

    </geekhall>
</div>

<script>
    Vue.config.productionTip = false
    Vue.component("geekhall", {
        props: ['geek'],
        template: '<li>{{geek}}</li>'
    });

    const vm = new Vue({
        el: '#root',
        data: {
            items: ["Java", "Python", "Django", "Vue"]
        }
    });
</script>
```

