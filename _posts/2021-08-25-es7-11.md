---
git@gitee.com:sjdt/geekhall.cn.gitlayout: post
title:  "ES7-11新特性"
date:   2021-08-25 12:10:25 +0800
categories: ES7
---

# ES7-ES11新特性

## ES7
### Array.prototype.includes()
```javascript
const mingzhu = ['西游记', '红楼', '水浒','三国'];

console.log(mingzhu.includes('三国'));  // true
console.log(mingzhu.includes('金瓶梅'));  // false
```

### 指数操作符
```javascript
console.log(2**8);          // 256
```

## ES8
### async 和 await
async和await两种语法结合可以让异步代码像同步代码一样。

#### async函数
* async函数的返回值为promise对象。
* promise对象的结果由async函数执行的返回值决定

```javascript
async function getData(){
    // 返回结果是一个Promise对象
    return 'GeekHall';
}

const result = getData();
console.log(result); 
```
![](https://yinyang.space/img/20210825_es7_1.png)

```javascript
async function getData(){
    // 抛出错误，返回一个失败的Promise
    throw new Error('出错了');
}

const result = getData();
console.log(result); 
```

![](https://yinyang.space/img/20210825_es7_2.png)

使用Promise
```javascript
async function getData(){
    return new Promise((resolve, reject) => {
        resolve('成功的数据');
    });
}

const result = getData();

// 调用then方法
result.then(value => {
    console.log(value);
}, reason => {
    console.warn(reason);
});

```
![](https://yinyang.space/img/20210825_es7_3.png)


#### await表达式
* await必须写在async函数中
* await右侧的表达式一般为promise对象
* await返回的是promise成功的值
* await的promise失败了，就会抛出异常，需要通过try...catch捕获异常

```javascript

// 创建Promise对象
const p = new Promise((resolve, reject) => {
    resolve("成功的值！！");
});

// await 要放在async函数中
async function main(){
    let result = await p;
    console.log(result);
}

// 调用函数
main();
```

异常情况
```javascript
// 创建Promise对象
const p = new Promise((resolve, reject) => {
    reject("失败的值！！");
});

// await 要放在async函数中
async function main(){
    try{
        let result = await p;
        console.log(result);
    } catch (e){
        console.log(e);
    }
}

// 调用函数
main();
```


async和await的结合使用：

下面内容保存为sample.js
```javascript
const fs = require('fs');

function readFile1(){
    return new Promise((resolve, reject) => {
        fs.readFile("./resources/file1.md", (err, data) =>{
            // 如果失败
            if (err) reject(err);

            // 如果成功
            resolve(data);
        })
    })
}


function readFile2(){
    return new Promise((resolve, reject) => {
        fs.readFile("./resources/file2.md", (err, data) =>{
            // 如果失败
            if (err) reject(err);

            // 如果成功
            resolve(data);
        })
    })
}

function readFile3(){
    return new Promise((resolve, reject) => {
        fs.readFile("./resources/file3.md", (err, data) =>{
            // 如果失败
            if (err) reject(err);

            // 如果成功
            resolve(data);
        })
    })
}

// 声明一个async函数
async function main(){
    let file1 = await readFile1();
    let file2 = await readFile2();
    let file3 = await readFile3();

    console.log(file1.toString());
    console.log(file2.toString());
    console.log(file3.toString());
}

main();
```

然后执行：`node sample.js` ，即可读取三个文件的内容。



### 使用async和await发送ajax请求
```javascript

// 发送Ajax请求，返回的结果是Promise对象。
function sendAjax(url){
    return new Promise((resolve,reject) => {
        
        // 创建对象
        const x = new XMLHttpRequest();

        // 初始化
        x.open('GET', url);

        // 发送
        x.send();

        // 事件绑定
        x.onreadystatechange = function(){
            if (x.readyState === 4){
                if (x.status >= 200 && x.status < 300) {
                    // 成功
                    resolve(x.response);
                } else {
                    // 失败
                    reject(x.status);
                }
            }
        }
    });
}

// promise then 方法测试
// sendAjax("https://api.apiopen.top/getJoke").then(value => {
//     console.log(value);
// }, reason => {
//     console.warn(reason);
// });


// async 与 await 方法测试 以后使用axios
// 推荐的做法是axios发请求，await接结果。
async function main (){
    // 发送ajax请求
    let result = await sendAjax("https://api.apiopen.top/getJoke");
    console.log(result);
}
main();
```
